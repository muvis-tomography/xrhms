"""
    Copyright 2023 University of Southampton
    Dr Philip Basford
    Î¼-VIS X-Ray Imaging Centre

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.

    How to handle the xtek files generated by Nikon scanners
    Philip Basford
    XRH Project
    October 2020
"""
import os
import logging
import xml.etree.ElementTree as ET
from configparser import ConfigParser
from pathlib import Path

import shutil
import sh
from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.utils import timezone

from xrhms_exceptions import XrhmsIgnore
from xtek_parameters import  XTEKCT_MODE, XTEKHELIX_MODE, get_xtek_param_list

from xrh_utils import (
    calculate_file_hash,
    convert_filesize,
    find_mount_point,
    free_space,
    get_file_modified_time,
    stack2xyslice,
    strip_ansi_codes,
    tiff2png,
)

from scans.models import (
    NikonCTScan,
    RefinedRawData,
    RefinedRawExtension,
    ScanAttachmentType,
    ScanAttachmentTypeSuffix,
    ScanAttachment,

)
from scans.reports import generate_basic_report_tasks

from dataset_parser import DatasetParser

RECON_EXTENSIONS = ["vol", "raw"]

class XtekParser(DatasetParser):
    """
        Parse the information from xtek files
        See dataset_parser.py for details of the inherited methods
    """

    EXTENSIONS = [".xtekct", ".xtekhelixct"]
    def __init__(self, log_level=logging.WARN):
        super().__init__(log_level)
        self._log_level = log_level
        self._logger = logging.getLogger("Xtek Parser")

    def extensions(self):
        return self.EXTENSIONS

    def get_model(self):
        return NikonCTScan

    def list_files(self, directory):
        return super()._list_files(directory, self.EXTENSIONS)

    def process_file(self, dataset, scan_data=None):
        if not scan_data:
            raise ValueError("scan_data must be passed in")
        self._logger.debug("Reading XTek file: %s", dataset)
        #setup parser using options suggested by Nick Hale
        #allows duplicates of the same section / options
        xtekct_parser = ConfigParser(strict=False)
        #allows case sensitivity
        xtekct_parser.optionxform = str

        xtekct_parser.read(dataset)
        if xtekct_parser.has_section("XTekCT"):
            mode = XTEKCT_MODE
            self._logger.info("Using XTekCT mode")
        elif xtekct_parser.has_section("XTekHelixCT"):
            mode = XTEKHELIX_MODE
            self._logger.info("Using XTekHelixCT mode")
        else:
            self._logger.error("Cannot find either XTekCT or XTekHelixCT section in file")
            raise ValueError("Cannot find either XTekCT or XTekHelixCT section in file")
        if xtekct_parser.has_section("soton"):
            self._logger.debug("Has southampton specific setting")
            if xtekct_parser.getboolean("soton", "XrhmsIgnore"):
                raise XrhmsIgnore("Ignoring xtekct file due to specificied value")
        #Helix and CT mode have different section headings but largely the same fields
        self._logger.debug("Getting data from xtek file")
        for (target, mode, section, source) in get_xtek_param_list(mode):
            if xtekct_parser.has_option(section, source):
                if mode == "int":
                    setattr(scan_data, target, xtekct_parser.getint(section, source))
                elif mode == "float":
                    setattr(scan_data, target, xtekct_parser.getfloat(section, source))
                elif mode == "string":
                    value = xtekct_parser.get(section, source)
                    if value == "":
                        value = None
                    setattr(scan_data, target, value)
                elif mode in ("bool", "boolean"):
                    setattr(scan_data, target, xtekct_parser.getboolean(section, source))
                else:
                    self._logger.error("Unknown parameter type %s", mode)
                    raise ValueError("Unknown parameter type {}".format(mode))
                self._logger.debug(
                    "Read value %s from %s to %s",
                    xtekct_parser.get(section, source), source, target)
            else:
                self._logger.debug("Option %s not found in file", source)

        self._logger.debug("Getting data from xml file")
        ctprofile_filename = Path(
            dataset.parent,
            "{}.ctprofile.xml".format(dataset.stem))
        if ctprofile_filename.exists():
            ctprofile_data = ET.parse(ctprofile_filename).getroot()
            imaging_settings = ctprofile_data.find("ImagingSettings").attrib
            scan_data.binning = int(imaging_settings["binning"])
            scan_data.exposure = int(imaging_settings["exposure"])
            scan_data.gain = int(imaging_settings["gain"])
            scan_data.xray_head = ctprofile_data.find("XrayHead").text
            try:
                scan_data.brightness = int(imaging_settings["brightness"])
            except KeyError:
                #This is no longer in files from IX6
                pass
            scan_data.digital_gain = int(imaging_settings["digitalGain"])
            scan_data.accumulation = int(imaging_settings["accumulation"])
            scan_data.white_to_black_latency = int(imaging_settings["WhiteToBlackLatency"])
            scan_data.black_to_white_latency = int(imaging_settings["BlackToWhiteLatency"])
            scan_data.white_to_white_latency = int(imaging_settings["WhiteToWhiteLatency"])
            scan_data.lines = int(imaging_settings["lines"])
            scan_data.frames_per_projection = int(ctprofile_data.find("FramesPerProjection").text)
            scan_data.max_pixels_to_shuttle = int(ctprofile_data.find("MaxPixelsToShuttle").text)
            if ctprofile_data.find("HelicalScan").text == "true":
                self._logger.debug("Parsing helical params from CTProfile")
                helical_params = ctprofile_data.find("HelicalParameters")
                scan_data.helical_continuous_scan = \
                    (helical_params.find("ContinuousScan").text == "true")
                scan_data.helical_derivative_type = helical_params.find("DerivativeType").text
                scan_data.helical_sample_top = float(helical_params.find("SampleTop").text)
                scan_data.helical_sample_bottom = float(helical_params.find("SampleBottom").text)
                scan_data.helical_projections_per_rotation = int(
                    helical_params.find("ProjectionsPerRotation").text)
                range_check = helical_params.find("VerticalRangeCheck")
                scan_data.helical_upper_position_checked = (
                    range_check.find("UpperPositionChecked").text == "true")
                scan_data.helical_lower_position_checked = (
                    range_check.find("LowerPositionChecked").text == "true")
                scan_data.helical_upper_check_position = float(
                    range_check.find("UpperCheckPosition").text)
                range_check = helical_params.find("VerticalRangeCheck")
                scan_data.helical_lower_check_position = float(
                    range_check.find("LowerCheckPosition").text)
                scan_data.helical_upper_magnification_position = float(
                    range_check.find("UpperMagnificationPosition").text)
                scan_data.helical_lower_magnification_position = float(
                    range_check.find("LowerMagnificationPosition").text)
        else:
            self._logger.debug("no CTprofile file found")
        checksum = calculate_file_hash(dataset)
        self._logger.debug("File checksum: %s", checksum)
        scan_data.checksum = checksum
        scan_data.save()
        scan_data.save_sidecar()
        return scan_data

    def process_associated_files(self, db_entry):
        self._store_ctprofile_file(db_entry)
        self._store_xtek_file(db_entry)
        self._store_ang_file(db_entry)
        self._store_refined_files(db_entry)
        self._generate_extra_listing(db_entry)
        self._process_videos(db_entry)
        if (
                db_entry.sample is None or
                not db_entry.sample.is_confidential()):
            self._store_0_deg_projection(db_entry)
            self._store_90_deg_projection(db_entry)
            self._store_xy_slice(db_entry)
        else:
            self._logger.info("Commerical sample not processing projections")


    def _store_ctprofile_file(self, scan_entry):
        """
            Add the complete xml file to the system
            :param Scan scan_entry: The db record for the scan entry
        """
        dir_name = scan_entry.full_path().parent
        ctprofile_file = Path(dir_name, "{}.ctprofile.xml".format(Path(scan_entry.filename).stem))
        if ctprofile_file.exists():
            self._logger.debug("CT profile file found")
            ctprofile_checksum = calculate_file_hash(ctprofile_file)
            ctprofile_file_type = ScanAttachmentType.objects.get(name="CT Profile")
            name = Path(ctprofile_file).name
            try:
                ctprofile_entry = ScanAttachment.objects.get(
                    scan=scan_entry,
                    attachment_type=ctprofile_file_type)
            except ObjectDoesNotExist:
                ctprofile_entry = ScanAttachment(
                    scan=scan_entry,
                    attachment_type=ctprofile_file_type,
                    name=name)
            if ctprofile_entry.checksum != ctprofile_checksum:
                self._logger.debug("CT Profile checksum: BAD")
                ctprofile_entry.attachment.delete(save=False)
                ctprofile_entry.checksum = ctprofile_checksum
                ctprofile_entry.editable = False
                ctprofile_entry.attachment.save(name, open(ctprofile_file, "r"))
            else:
                self._logger.debug("CT Profile checksum: OK")

    def _store_xtek_file(self, scan_entry):
        """
            Store the xtek file for the scan into the management system
            :param Scan scan_entry: The db record for the scan entry
        """
        xtek_file_checksum = scan_entry.checksum # This should have been previously updated
        xtek_file_type = ScanAttachmentType.objects.get(name="Xtek File")
        name = scan_entry.filename
        try:
            xtek_file_entry = ScanAttachment.objects.get(
                scan=scan_entry,
                attachment_type=xtek_file_type)
        except ObjectDoesNotExist:
            xtek_file_entry = ScanAttachment(
                scan=scan_entry,
                name=name,
                attachment_type=xtek_file_type)
        if xtek_file_checksum != xtek_file_entry.checksum:
            self._logger.debug("Xtek attachment checksum: BAD")
            xtek_file_entry.attachment.delete(save=False)
            xtek_file_entry.checksum = xtek_file_checksum
            xtek_file_entry.editable = False
            xtek_file_entry.attachment.save(name, open(scan_entry.full_path(), "r"))
        else:
            self._logger.debug("Xtek attachment checksum: OK")

    def _store_ang_file(self, scan_entry):
        """
            Add the angle file into the DB
            :param Scan scan_entry: The db record for the scan entry
        """
        dir_name = scan_entry.full_path().parent
        self._logger.debug("Looking in %s for angle files", dir_name)
        ang_file = Path(dir_name, "_ctdata.txt")
        if  not ang_file.exists():
            self._logger.debug("_ctdata.txt not found")
            ang_file = Path(dir_name, "{}.ang".format(Path(scan_entry.filename).stem))
            self._logger.debug("Trying %s instead", ang_file)
        if ang_file.exists():
            self._logger.debug("Ang file found")
            ang_file_checksum = calculate_file_hash(ang_file)
            ang_file_type = ScanAttachmentType.objects.get(name="Angle File")
            #Get angle object from db if it exists
            try:
                ang_file_entry = ScanAttachment.objects.get(
                    scan=scan_entry,
                    attachment_type=ang_file_type)
            except ObjectDoesNotExist:
                ang_file_entry = ScanAttachment(
                    scan=scan_entry,
                    attachment_type=ang_file_type,
                    name="_ctdata.txt")
            if ang_file_entry.checksum != ang_file_checksum:
                self._logger.debug("Angle file checksum: BAD")
                ang_file_entry.attachment.delete(save=False)
                ang_file_entry.checksum = ang_file_checksum
                ang_file_entry.editable = False
                ang_file_entry.attachment.save(ang_file.name, open(ang_file, "r"))
            else:
                self._logger.debug("Angle file checksum: OK")
        else:
            self._logger.debug("Angle file not found")



    def _store_xy_slice(self, scan_entry):
        """
            If a reconstructed volume is available generate the xy slice and store it
            :param Scan scan_entry: The db record for the scan entry
        """
        if scan_entry.xyslice.name is None or scan_entry.xyslice.name == '':
            self._logger.debug("No XY slice currently stored")
            pixels_x = scan_entry.voxels_x
            pixels_y = scan_entry.voxels_y
            pixels_z = scan_entry.voxels_z
            xtek_file = scan_entry.full_path()
            recon_dir = scan_entry.recon_directory()
            if recon_dir.is_dir():
                for extension in RECON_EXTENSIONS:
                    recon_file = Path(recon_dir, "{}.{}".format(xtek_file.stem, extension))
                    if recon_file.exists():
                        break
                if os.path.exists(recon_file):
                    self._logger.debug("Found recon file: %s", recon_file)
                    try:
                        (temp_dir, tiff, png) = stack2xyslice(
                            recon_file, pixels_x, pixels_y, pixels_z)
                        scan_entry.xyslice.save(tiff, open(Path(temp_dir.name, tiff), "rb"))
                        scan_entry.xyslice_png.save(png, open(Path(temp_dir.name, png), "rb"))
                    except ValueError:
                        self._logger.error("Unable to generate xy slice")
                        return
                    try:
                        generate_basic_report_tasks(scan_entry, self._log_level)
                        self._logger.debug("Basic report tasks queued")
                    except ValueError:
                        self._logger.error("Unable to queue report tasks")
                else:
                    self._logger.warning("Unable to find recon file %s", recon_file)
            else:
                self._logger.warning("Unable to find recon directory %s", recon_dir)
        else:
            self._logger.debug("XY slice already stored")

    def _store_0_deg_projection(self, scan_entry):
        """
            Store the 0 degree projection from the scan
            :param Scan scan_entry: The db record for the scan entry
        """
        if scan_entry.projection0deg.name is None or scan_entry.projection0deg.name == '':
            self._logger.debug("No 0 degree projection currently stored")
            xtek_file = scan_entry.full_path()
            proj = Path(xtek_file.parent, "{}_{:04d}.tif".format(xtek_file.stem, 1))
            self._logger.debug("looking for %s", proj)
            if os.path.exists(proj):
                self._logger.debug("Found 0 degree projection")
                scan_entry.projection0deg.save(proj.name, open(proj, "rb"))
                (temp_dir, png) = tiff2png(proj)
                scan_entry.projection0deg_png.save(png, open(Path(temp_dir.name, png), "rb"))
            else:
                self._logger.info("0 degree projection not found")
        else:
            self._logger.debug("0 degree projection already stored")

    def _store_90_deg_projection(self, scan_entry):
        """
            Store the 90 degree projection from the scan
            :param Scan scan_entry: The db record for the scan entry
        """
        if scan_entry.projection90deg.name is None or scan_entry.projection90deg.name == '':
            self._logger.debug("No 90 degree projection currently stored")
            proj_number = scan_entry.proj90_index()
            if proj_number:
                self._logger.info("Projection index %4d", proj_number)
                xtek_file = scan_entry.full_path()
                proj = Path(xtek_file.parent, "{}_{:04d}.tif".format(xtek_file.stem, proj_number))
                self._logger.debug("looking for %s", proj)
                if os.path.exists(proj):
                    self._logger.debug("Found 90 degree projection")
                    scan_entry.projection90deg.save(proj.name, open(proj, "rb"))
                    (temp_dir, png) = tiff2png(proj)
                    scan_entry.projection90deg_png.save(png, open(Path(temp_dir.name, png), "rb"))
                else:
                    self._logger.info("90 degree projection not found")
            else:
                self._logger.warning("No projection number calculated")
        else:
            self._logger.debug("90 degree projection already stored")

    def copy_raw(self, scan, destination):
        if not destination.exists():
            return (False, "Destination must exist\n")
        file_list = scan.raw_files()
        file_size = scan.raw_size()
        available_space = free_space(find_mount_point(destination))
        self._logger.debug(
            "Space needed: %s, Space available: %s",
            convert_filesize(file_size),
            convert_filesize(available_space))
        if file_size >= available_space:
            return (False, "Not enough space left on destination\n")
        self._logger.debug("Files to copy: %d", len(file_list))
        for fname in file_list:
            shutil.copy(fname, destination, follow_symlinks=False)
        return (True, "")

    def copy_recon(self, scan, destination, include_metadata=False):
        if not destination.exists():
            return (False, "Destination must exist\n")
        recon_dir = scan.recon_directory()
        self._logger.debug("Reconstruction directory: %s", recon_dir)
        if not recon_dir.exists():
            return (False, "Cannot find reconstruction directory for scan\n")
        dir_size = scan.recon_size()
        available_space = free_space(find_mount_point(destination))
        self._logger.debug(
            "Space needed: %s, Space available: %s",
            convert_filesize(dir_size),
            convert_filesize(available_space))
        if dir_size >= available_space:
            return (False, "Not enough space left on destination\n")
        shutil.copytree(recon_dir, Path(destination, recon_dir.name))
        self._logger.debug("Copying complete")
        if include_metadata:
            self._logger.debug("Also including metadata files")
            shutil.copy(scan.full_path(), destination, follow_symlinks=False)
            ctprofile_filename = Path(
            Path(scan.path).name,
            "{}.ctprofile.xml".format(Path(scan.name).stem))
            if ctprofile_filename.exists():
                self._logger.debug("CT profile found")
                shutil.copy(ctprofile_filename, destination, follow_symlinks=False)
            else:
                self._logger.debug("CT profile file not found")

        return (True, "")

    def _store_refined_files(self, scan_entry):
        """
            Store the refined files for the scan entry
            :param Scan scan_entry: The db record to look for refined files for
        """
        recon_dir = scan_entry.recon_directory()
        if not recon_dir.exists():
            self._logger.info("No recon directory therefore no refined raw files")
            return
        extensions = [".{}".format(ext.extension) for ext in RefinedRawExtension.objects.all()]
        self._logger.debug("Looking for %r files in %s", extensions, recon_dir)
        excluded_dirs = [settings.VIDEO_FOLDER, settings.EXTRA_FOLDER]
        self._logger.debug("Excluding files in %r", excluded_dirs)
        files = super()._list_files(recon_dir, extensions)
        self._logger.debug("Found %d files", len(files))
        for f_name in files:
            self._logger.debug("Processing %s", f_name)
            f_path = Path(f_name).parent
            name = f_name.name
            rel_path = f_path.relative_to(recon_dir.parent)
            path_parts = rel_path.parts
            if (
                    len(path_parts) >=2 and #it's in a sub directory within the recon folder
                    path_parts[1] in excluded_dirs):  #it's in an excluded dir
                self._logger.debug("Skipping file %s", f_name)
                continue
            try:
                data_obj = RefinedRawData.objects.get(name=name, path=rel_path, scan=scan_entry)
            except ObjectDoesNotExist:
                data_obj = RefinedRawData(name=name, path=rel_path, scan=scan_entry)
                self._logger.debug("Adding entry")
                if scan_entry.sample is not  None and scan_entry.sample.is_confidential():
                    data_obj.shareable = False # if it's confidential it can't be shared publically
            modified_time = get_file_modified_time(f_name)
            self._logger.debug("Last modified: %s", modified_time)
            if not data_obj.file_modified or data_obj.file_modified < modified_time:
                self._logger.debug("Updating modified time")
                data_obj.file_modified = modified_time
                data_obj.last_updated = timezone.now()
                data_obj.save()

    def _generate_extra_listing(self, scan_entry):
        """
            Store the listing of files in the extra folder for the scan
            :param Scan scan_entry - the scan to look for files for
        """
        extra_folder = scan_entry.recon_extra_dir()
        self._logger.debug("Looking for files in %s", extra_folder)
        if extra_folder.is_dir():
            try:
                scan_entry.extra_listing = strip_ansi_codes(
                    str(sh.tree("-R", "-sh", str(extra_folder))))
            except Exception as err: #pylint: disable=broad-except
                self._logger.error("Unable to index extra folder")
                self._logger.debug(err)
                return # don't update the timestamp
        else:
            self._logger.info("Extra folder does not exist")
            scan_entry.extra_listing = ""
        scan_entry.extra_listing_last_updated = timezone.now()
        scan_entry.save()

    def _process_videos(self, scan_entry):
        """
            Look in the video folder and automatically attach the videos in there to the record
        """
        folder = scan_entry.recon_video_dir()
        if not folder.exists():
            self._logger.info("Video folder not found")
            return
        self._logger.debug("Looking in folder %s for videos", folder)
        for extension in settings.SCAN_VIDEO_EXTENSION:
            self._logger.debug("Looking for %s files", extension)
            files = folder.glob("**/*.{}".format(extension))
            for fname in files:
                self._logger.debug("Processing %s", fname)
                if scan_entry.scanattachment_set.filter(name=fname.name).exists():
                    self._logger.debug("Already has an entry - skipping")
                    continue # alredy added this record
                for atype_suffix in ScanAttachmentTypeSuffix.objects.all():
                    if atype_suffix.suffix in fname.name:
                        atype = atype_suffix.attachment_type
                        self._logger.debug("attachment type %s found", atype)
                        attachment = ScanAttachment()
                        attachment.name = fname.name
                        attachment.attachment_type = atype
                        txt_file = fname.with_suffix(".txt")
                        if txt_file.exists():
                            attachment.notes = open(txt_file).read()
                        else:
                            self._logger.warning("text file not found")
                        # checksum ignored because files can be big
                        attachment.scan = scan_entry
                        attachment.attachment.save(fname.name, open(fname, "rb"))
                        attachment.save()
                        break # found the suffix so no need to look further
